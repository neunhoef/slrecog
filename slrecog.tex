\documentclass[a4paper,11pt]{article} 
%last modified: Akos, 8 August 2011
\usepackage{amsfonts, amsbsy, amsmath, amsthm, amssymb, latexsym}
%\usepackage{mathrsfs}
%\usepackage{pdfsync}
\usepackage[top=34mm,right=34mm,bottom=34mm,left=34mm]{geometry}
%\usepackage{mathptmx}
%\usepackage{stmaryrd}
%\usepackage{bm}
%\usepackage{eucal}
%\usepackage{pslatex}
\usepackage{fancyhdr}

%\usepackage{showkeys}

%\usepackage{setspace}
%\usepackage[all]{xy}
%\topmargin=-6mm \textheight=230mm \textwidth=145mm
\headheight=14pt
%\DeclareMathAlphabet{\bm}{OT1}{ptm}{b}{it}
%\renewcommand{\baselinestretch}{1.3}

\def\hal{\unskip\nobreak\hfill\penalty50\hskip10pt\hbox{}\nobreak

\hfill\vrule height 5pt width 6pt depth 1pt\par\vskip 2mm}

\parskip 1mm

\def\thefootnote{\fnsymbol{footnote}}

\def\Soc{\operatorname{Soc\,}}
\def\GF{\operatorname{GF\,}}
\def\Tr{\operatorname{Tr\,}}
\def\GL{\operatorname{GL}}
\def\I{\operatorname{I}}
\def\GaL{\operatorname{\G L}}
\def\AGL{\operatorname{AGL}}
\def\ASL{\operatorname{ASL}}
\def\AGaL{\operatorname{A\G L\,}}
\def\SL{\operatorname{SL}}
\def\SO{\operatorname{SO}}
\def\po{\operatorname{P\Omega}}
\def\PGL{\operatorname{PGL}}
\def\PGaL{\operatorname{P\G L}}
\def\PG{\operatorname{PG}}
\def\PSL{\operatorname{PSL}}
\def\PSiL{\operatorname{P\Si L}}
\def\Sp{\operatorname{Sp}}
\def\PSp{\operatorname{PSp}}
\def\Sz{\operatorname{Sz\,}}
\def\SU{\operatorname{SU\,}}
\def\PSU{\operatorname{PSU\,}}
\def\GaL{\operatorname{\G L}}
\newcommand{\Sym}{{\rm Sym}} 
\newcommand{\Alt}{{\rm Alt}} 
\newcommand{\Aut}{{\rm Aut}}
\newcommand{\stab}{{\rm stab}}
\newcommand{\Inn}{{\rm Inn}}
\newcommand{\soc}{{\rm soc}}
\newcommand{\fix}{{\rm fix}}
\newcommand{\rad}{{\rm rad}}
\newcommand{\mindeg}{{\rm mindeg}}
\newcommand{\Cl}{{\rm Cl}}
\newcommand{\GAP}{{\sl {GAP}}}
\newcommand{\Fix}[1]{\mathrm{Fix}(#1)}
\def\ve{\varepsilon}
\def\Rad{{\rm Rad}}

\newcommand{\B}{\mathcal{B}}

%\pagestyle{fancy}
%\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}} 
%\renewcommand{\chaptermark}[1]{\markboth{\chaptername\ \thechapter.\ #1}{}}
%\fancyhead[RE]{\em \leftmark}
%\fancyhead[LO]{\em \rightmark}
%\fancyhead[LE,RO]{\thepage}
%\lfoot{}
%\cfoot{}
%\rfoot{}

%\pagestyle{fancy}
%\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
%\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}} 
%\lhead{\em \leftmark}
%\chead{}
%\rhead{\thepage}
%\lfoot{}
%\cfoot{}
%\rfoot{}

%\renewcommand{\bibname}{References}
%\setcounter{tocdepth}{2}

\renewcommand{\a}{\alpha}
\renewcommand{\b}{\beta}
\newcommand{\im}{\mathrm{Im}}
\newcommand{\Ker}{\mathrm{Ker}}
\newcommand{\FF}{\mathbb{F}}
\newcommand{\eval}{\mathrm{eval}}
\newcommand{\FFF}{\mathbb{F}_{q^2}}
\renewcommand{\v}{\varphi} \newcommand{\e}{\varepsilon}
\renewcommand{\bf}{\textbf} \renewcommand{\L}{\Lambda}
\renewcommand{\l}{\lambda} \renewcommand{\O}{\Omega}
\renewcommand{\v}{\varphi} \newcommand{\z}{\mathbb{Z}}
\newcommand{\into}{\hookrightarrow} \renewcommand{\to}{\rightarrow}
\newcommand{\too}{\longrightarrow} \newcommand{\s}{\sigma}
\renewcommand{\o}{\circ} \newcommand{\T}{\Theta}
\newcommand{\h}{H^{0}} \newcommand{\C}{\mathcal{C}}
\newcommand{\G}{\bar{G}} \newcommand{\E}{\mathcal{E}}
\newcommand{\D}{\bar{D}}
\renewcommand{\H}{\bar{H}} \newcommand{\ms}{\mathcal{S}}
\renewcommand{\sb}{\mathscr{B}}
\newcommand{\mS}{\mathfrak{S}}
\newcommand{\sm}{\small}
\newcommand{\ns}{\normalsize}
\newcommand{\leqs}{\leqslant}
\newcommand{\geqs}{\geqslant}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\perps}{\vdash} \newcommand{\wtilde}{\widetilde}
\newcommand{\what}{\widehat} \newcommand{\ub}{\underline{b}}
\newcommand{\ds}{\displaystyle} \newcommand{\vs}{\vspace{3mm}}
\newcommand{\hh}{\hspace{5mm}} \newcommand{\vsp}{\vspace{2mm}}
\newcommand{\hhh}{\hspace{3.5mm}}
\newcommand{\fpr}{\mbox{{\rm fpr}}(x,\O)}
\def\ndiv{ {\not\kern-.5pt\hbox{\big |}\,} }

\newtheorem{theorem}{Theorem} 
\newtheorem{lemma}{Lemma}
\newtheorem{propn}{Proposition}
\newtheorem{remk}{Remark} 
\newtheorem{corol}{Corollary}
\newtheorem{ex}{Example}
\newtheorem{definition}{Definition}
\newtheorem*{nota}{Notation}
\newtheorem{thm}{Theorem}[section] 
\newtheorem{defn}[thm]{Definition}
\newtheorem{prop}[thm]{Proposition} 
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary} 
\newtheorem{rem}[thm]{Remark}
\newtheorem{cla}[thm]{Claim}

\begin{document}

\title{Constructive recognition of special linear groups in their natural representation}

\author{Max Neunh\"offer\footnote{\texttt{neunhoef@mcs.st-and.ac.uk}} \\
Mathematical Institute \\
University of St Andrews\\
North Haugh \\
St Andrews, Fife, KY16 9SS\\ Scotland, UK \\ \and \'Akos Seress\footnote{\texttt{akos@math.ohio-state.edu}  Research partially supported by the NSF and by ARC Grant DP1096525}  \\ School of Mathematics and Statistics \\ University of Western Australia \\ Crawley, WA 6009, Australia \\ and  Department of Mathematics \\ The Ohio State University \\ Columbus, OH 43210, USA}

\date{}
\maketitle



\begin{abstract}

\end{abstract}

\section{Introduction}
\label{introduction}
A recent active area of computational group theory is the so-called
{\em matrix group recognition project}. Let $V$ be a finite dimensional
vector space over a finite field $\GF(q)$. Given $G =\langle X \rangle
\le \GL(V)$, the goal is to compute quantitative and structural
information about $G$ such as the order, a composition series, and
important characteristic subgroups like the largest solvable normal
subgroup of $G$.

All practical algorithms for matrix group recognition \cite{LG99},
\cite{NS06}, \cite{OB09} use a tree-like structure of homomorphisms
to divide the input group $G$ into smaller factors, solve the basic
algorithmic problems in the factors, and then combine the results for
the entire group $G$. This divide-and-conquer approach bottoms out
when we reach a leaf node in the tree-like data structure, i.e., a
quasisimple matrix group where there is no homomorphism breaking the
group into significantly smaller pieces exists.

In a leaf node, the basic task is the {\em constructive recognition} of
the group $H$ at hand. This means the construction of a homomorphism
$\lambda: H \to C$, where $C$ is a natural copy of $H$; in the case
of classical groups, $C$ is simply the smallest dimensional matrix
representation. The homomorphism $\lambda$ must be effective in the
sense that for any $h \in H$, we must be able to construct $h\lambda$
and for any $c \in C$, we must be able to compute a representative in
$c\lambda^{-1}$. A key part of this procedure is to solve the {\em
constructive membership problem} in $C$. This means the construction of
a ``nice'' generating set $Y$ for $C$ and setting up a data structure
so that for any $g \in C$, there is a fast algorithm to write a
straight-line program reaching $g$ from $Y$. Recall that a {\em
straight-line program} (SLP) reaching $g$ from $Y$ is a series of
expressions $w_1,w_2,\ldots,w_m$ so that
\begin{itemize}
\item Each $w_j$ is a symbol for an element of $Y$, or
$w_j=(w_k,w_{\ell})$ for some $k,\ell <j$, or $w_j=(w_k,-1)$ for some
$k<j$.
\item The evaluated value of $w_m$ is $\eval(w_m)=g$.
\end{itemize}
We evaluate SLPs the natural way: if $w_j=(w_k,w_{\ell})$ then
$\eval(w_j)=\eval(w_k) \cdot \eval(w_{\ell})$ and if $w_j=(w_k,-1)$ then
$\eval(w_j)=(\eval(w_k))^{-1}$.

The present paper solves the constructive membership problem in the
groups $\SL(d,q)$, given as $G = \langle X \rangle \le \GL(V)$, for a
$d$-dimensional vector space $V$ over $\GF(q)$. To describe the output
of the algorithm, we need the following notation and definition.

Let $q=p^e$ for some prime $p$ and let $(\varepsilon_1, \ldots, \varepsilon_e)$
be a basis of $\GF(q)$ over $\GF(p)$.
% such that we can easily express elements of $\GF(q)$ as vectors in this basis in practice. 
For a basis $B=(b_1,b_2,\ldots,b_d)$    
of $V$ and $\beta \in \GF(q)$, let $E_{ij}(\beta) \in \SL(V)$ be      
the group element with matrix (in the basis $B$) $M=(m_{k\ell})$ with   
$m_{k\ell}=1$ if $k=\ell$; $m_{ij}=\beta$; and all other entries of    
$M$ equal to $0$.                                                       

For $n \le d$, we define the standard generators of $\SL(n,q)$ with 
respect to $B$ the following way.

\begin{definition}[Standard generators for $\SL(n,q)$]
{\em
Let $G = \left< Y \right>$ be a subgroup of $\GL(V)$ that 
acts as $\SL(V_n)$ on the subspace $V_n:=\langle b_1,\ldots,b_n \rangle$ and 
fixes the $(d-n)$-dimensional subspace $\langle b_{n+1},\ldots,b_d\rangle$ pointwise.
Then $Y$ is called a \emph{set of standard generators for
$\SL(n,q)$ with respect to the basis $(v_1, \ldots, v_d)$} of $V$, 
if it consists of the following  $2e+2$ elements:
\begin{itemize}
\item for $1 \le i \le e$, an element with matrix $E_{1,2}(\varepsilon_i)$;
\item for $1 \le i \le e$, an element with matrix $E_{2,1}(\varepsilon_i)$;
\item a permutation matrix corresponding to the permutation
$(n,n-1,\ldots,1)$ with the entry $(1,n)$ changed to $-1$ if $n$ is
even; and
\item a permutation matrix corresponding to the permutation
$(n,n-1,\ldots,2)$ with the entry $(2,n)$ changed to $-1$ if $n$ is
odd.
\end{itemize}
The $(-1)$ entries are of course introduced to ensure that the elements are
contained in $\SL(n,q)$.
}
\end{definition}

\begin{theorem}
\label{main}
There exists a Las Vegas algorithm that, given $\SL(d,q) \cong G 
= \langle X \rangle
\le \GL(V)$ in its natural representation, computes a straight-line
program $P$ to a new set $Y$ of generators together with a basis
$\B := (v_1, \ldots, v_d)$ of $V$
such that $Y$ is a set of standard generators for $\SL(d,q)$ with 
respect to $\B$.

The length of the straight-line program $P$ is $O(d^2e^2)$. The running
time of the algorithm is
\[
O(\log d) \xi  +O(d^3e^2 \log p \log d)\mu +\alpha,
\]
where $\xi$ is the cost of the construction of a (nearly) uniformly
distributed random group element, $\mu$ is the cost of a field operation
in $\GF(q)$, and $\alpha$ is the cost of one discrete logarithm
compuation in $\GF(q)$.
\end{theorem}

The random elements are taken in $O(\log^*d)$ different subgroups of
$G$, where $\log^*d$ is the length of the shortest tower of twos such
that \[2^{2^{\cdots ^2}} >d.\]

Recall that a randomized algorithm is {\em Las Vegas} if the output
is always correct; the algorithm may report failure, with an error
probability less than a bound prescribed by the user.

A key feature of our algorithm is that it works uniformly for all $q$;
alternative approaches, based on centralizer of involution computations,
have to distinguish between the cases $q$ odd or even (with the case
of characteristic $2$ much more complicated than the odd one). The
super-fast running time is achieved by manipulating vectors instead
of matrices, taking full advantage of the fact that we work with the
natural representation. A similar algorithm works for the natural
representation of all classical groups; we shall describe this extension
in a forthcoming paper.

The algorithm consists of two parts of quite different nature. In
the first part, we construct a subspace $W \le V$ of dimension $2$,
and a subgroup $H \le G$ acting as $\SL(2,q)$ on $W$ and fixing a
$(d-2)$-dimensional subspace of $V$. In the second part, we build
larger and larger subspaces $W_i$ and nice generators for the groups
$\SL(W_i)$, until we reach $\SL(V)$.

\section{Going down}
\label{going down}

In this section, we describe and analyze the first part of the
algorithm, the construction of a subgroup isomorphic to $\SL(2,q)$.
First, we present a subroutine that constructs an $\SL(4,q)$-subgroup.

\medskip\noindent
{\bf {Algorithm:}} \textsc{GoDownTo4Dim}

\noindent
{\bf {Input:}} $G = \langle X \rangle \cong \SL(V)$.
\begin{enumerate}
\item {\bf {assign}} $H := G$ {\bf {and}} $dim := d$;
\item {\bf {repeat}} 
\item \hspace*{1cm} $h:=$(pseudo)random$(H)$; $p_h(t):=$characteristic
polynomial of $h$;
\item \hspace*{1cm} $\{ f_i(t) \}:=$factors of $p_h(t)$;
\item \hspace*{1cm} {\bf {if}} $\exists f_i(t)$, $k:=\deg(f_i(t)$
relative prime to all other $\deg(f_j(t))$

 \hspace*{2cm} {\bf {and}} $1<k<2 \log(dim)$ {\bf {then}}
\item \hspace*{2cm} $\ell:=\prod_{j \ne i} \left(q^{\deg(f_j(t))}-1\right)$
\item \hspace*{2cm} $g:=h^{\ell}$; $r:=$(pseudo)random$(G)$;
\item \hspace*{2cm} $H:=\langle g,g^r \rangle$; $dim := 2*k$;
\item \hspace*{1cm} {\bf {fi}}
\item {\bf {until}} $dim=4$;
\item {\bf {if}} $H \cong \SL(4,q)$ {\bf {then}}
\item \hspace*{1cm} {\bf {output}} $H$;
\item \hspace*{1cm} {\bf {else output}} ``fail'';
\item {\bf {fi}}
\end{enumerate}

\section{Going up}
\label{going up}

In this section we describe and analyze the second part of the
algorithm, starting with a subgroup isomorphic to $\SL(2,q)$ and
ending with nice generators for the whole group $G$. The crucial
result is Theorem~\ref{double}, which provides the step to essentially
double the Lie rank of the subgroup for which we have nice generators.

For this section all our notation from previous sections remains in place.

\begin{theorem}[Doubling the dimension]
\label{double}
Let $2 \le n < d$ with $n$ odd when $n > 2$, 
let $\B := (v_1, v_2, \ldots, v_d)$ be a basis of $V$
and denote by $W_n$ the subspace of $V$ spanned by $(v_1, \ldots, v_n)$. 
Furthermore, let $P$ be a straight-line program
from $X$ to a generating set $Y_n$, which is a set of standard
generators for $\SL(n,q)$ with respect to the basis $\B$.
Let $n' := \min\{ 2n-1, d\}$.

Then there is an algorithm that computes a basis $\B' = (v'_1, \ldots,
v'_d)$ of $V$ together with a straight-line program $P'$ from $X$
to a generating set $Y_{n'}$, which is a set of standard generators
for $\SL(n',q)$ with respect to the basis $\B'$.

The running time of the algorithm is $O(\ldots)$ where $\xi$ is the
cost of the construction of a (nearly) uniformly distributed random
group element in $G$ and $\mu$ is the cost of a field operation in
$GF(q)$. The length of the resulting straight-line program $P'$ is
bounded above by $O(\ldots)$ plus the length of the straight-line
program $P$.
\end{theorem}

\emph{Remark:} The proposed algorithm is a bit lengthy. Therefore
we first present it in the running text and then write up a proof of its
correctness and the claims about running time and length of
straight-line programs.

\smallskip
Here is the general idea of the algorithm: With the help of a random 
element of $G$ we construct an element $c$ that conjugates the copy $H$
of $\SL(n,q)$ for which we have standard generators to a subgroup $H'$ of
$G$ which has two properties:
\begin{itemize}
\item The $n$-dimensional spaces on which $H$ and $H'$ actually act 
intersect in a $1$-dimensional space and
\item $\left< H, H' \right>$ is isomorphic to $\SL(n',q)$.
\end{itemize}
This setup allows us to choose a basis of the new $n'$-dimensional
subspace of $V$ very carefully, such that we can use $c$-conjugates of certain
transvections in $H$ to put together standard generators for $\SL(n',q)$
with respect to the new basis. 

Note that we do not have to construct the actual matrices of our standard
generators, since we only need a straight line program to express them in the
original generators anyway. However, since we know exactly to which
matrices with respect to our basis $\B$ these standard generators correspond,
we can actually do linear algebra computations to decide what products
and inversions we actually put into the resulting straight line program.
To ease the presentation, we use expressions like ``construct an element''
as a certain product, but we always just mean ``write the construction
into the resulting straight line program''.

One last comment is in order before we begin the description of the
algorithm. The generic case is that $n'=2n-1$ and $d$ is even bigger.
However, we can handle the case that $2n-1 \ge d$ with the very same
methods, which is why we introduce the variable $n'$ as the dimension
we are targetting in the current step.

Let $V_n := \left< v_1, v_2, \ldots, v_n\right>$. We denote by $(-|-)$
the standard scalar product on $V$ with respect to the basis $\B$,
that is $(v_i|v_j) = \delta_{i,j}$. For an element $g$ of $G$ we write
$\Fix c$ for its fixed space, and for a subgroup $K$ of $G$ we write
$\Fix K$ for the subspace of vectors which are fixed by all elements
of $K$.

\smallskip
\begin{enumerate}
\item Construct an element $s$ with fixed space of dimension $d-n+1$.

If $n=2$, we take $s := E_{1,2}(1)$ which is one of our known standard
generators, its fixed space is $\left< v_2, \ldots, v_d\right>$ and thus
has the right dimension. If $n > 2$, then it is by assumption odd.
In this case we take for $s$ the $(n-1)$-cycle if the characteristic $p$
is odd, and the $n$-cycle if it is odd. Both are amongst our
standard generators, so that we already have an SLP for them. The fixed
space is $\left< v_1, v_{n+1}, v_{n+2}, \ldots, v_d\right>$ in the first
case and $\left< v_1+v_2+\cdots+v_n, v_{n+1}, \ldots, v_d\right>$ in the
second case.

We emphasise once more that the element $s$ is ``constructed'' as an SLP in
the given standard generators of $\SL(n,q)$, but can at the same time be
written down explicitly as a matrix with respect to the basis $\B$ at
essentially no cost.
\item Find a good random element $c$.

The idea for this step is to create a uniformly distributed random element 
$c_1$ in $G$ and then take $c := s^{c_1}$. This is one of the few places
in this algorithm where we actually have to multiply $(d \times
d)$-matrices, since we have to base change $c_1$ into basis $\B$ and
then actually write down the matrix of $c$ with respect to $\B$. This
is necessary to perform the following linear algebra computations.

Since $c$ is a conjugate of $s$,
it has a fixed space of dimension $d-n+1$ as well, we denote this space
by $\Fix c$. We need the following
conditions on $c$, which we fulfill by repeatedly trying elements $c_1$
until they are satisfied:
\begin{itemize}
\item $\dim(V_n + V_n c) = n'$,
\item there is a $v \in V_n \cap \Fix c$ with $(v|v_n) = 1$,
\item $\dim(\Fix H \cap \Fix c) = d-n'$ if $n' < d$, and
\item one more condition on the entries of a submatrix of $c^{-1}$
\textbf{will be added later}.
\end{itemize}
In the generic case that $n'=2n-1$ the dimension of $V_n \cap \Fix c$
will always be equal to~$1$, since it is at least $1$ because the sum of the
dimensions of $V_n$ and of $\Fix c$ is $d+1$ and because of 
the first condition.
Then the second condition is just a condition on all non-zero vectors
in $V_n \cap \Fix c$. For $n' < 2n-1$ it is possible that $V_n \cap
\Fix c$ has higher dimension than $1$.
\item Modify $c$ such that it fixes $v_n$.

In this step we slightly modify $c$ in a controlled way, such that
$V_n \cap \Fix c$ contains the basis vector $v_n$. By our second
condition in step 2., this is now relatively cheap. Let $v$ be
the vector in $V_n \cap \Fix c$ with $(v|v_n)$ from above. We write
an element $T \in H$ in terms of the standard generators that fulfills
the following conditions: $v_iT = v_i$ for $1 \le i \le n-1$ and
$v_n T = v$. Then $Tc T^{-1}$ fixes $v_n$ and still fulfills the
conditions in step 2. We replace $c$ by $TcT^{-1}$.
\item Compute new basis $\B' = (v'_1,v'_2,\ldots,v'_d)$.

The purpose of this step is to compute our new basis, with respect to
which we can later produce standard generators for $\SL(n',q)$.
The first $n-1$ vectors of the new basis are equal to the vectors in
the old basis: $v'_i := v_i$ for $1 \le i \le n-1$. The basis vector
$v'_n$ is chosen in $V_n \cap \Fix c$ such that $(v'_n|v_n) = 1$,
which is possible by the second condition on $c$ in step 2. Let $\pi: V
\to V_n$ be the projection map to the first summand of $V = V_n \oplus
\left< v_n+1,\ldots,v_d\right>$. The basis vectors $v'_{n+1}, \ldots,
v'_{n'}$ are chosen as a linearly independent subset of the vectors
$\pi(v_1c), \ldots, \pi(v_{n-1}c)$. This is possible since $\dim(V_n +
V_n c) = n'$ and $v'_n \in V_n$ is fixed by $c$. We store the indices
$1 \le i_1 < \cdots < i_{n'-n} \le n-1$ of the selected vectors for later 
use. Finally, in the case $n' < d$, that is, $n'=2n-1$, we extend 
$(v'_1, \ldots, v'_{n'})$ to a basis $\B' =
(v'_1, \ldots, v'_d)$ of $V$ by choosing a basis of $\Fix H \cap
\Fix c$, which is possible by the third condition on $c$ in step 2. 
Note that $V_n = \left< v'_1, \ldots, v'_n\right>$ and $V_n + V_nc
= \left< v'_1, \ldots, v'_{n'}\right>$ and $\left< v'_{n+1}, \ldots,
v'_d\right> \subseteq \Fix H$.
\item Adjust the $\SL(n,q)$ standard generators.

In this step we have to adjust the standard generators for $\SL(n,q)$
with respect to $\B$ to transform them into standard generators
for $\SL(n,q)$ with respect to $\B'$. Fortunately, since 
$\left< v'_{n+1}, \ldots, v'_d\right> \subseteq \Fix H$ and the
first $n-1$ basis vectors are unchanged, all we have to do is to make
an adjustment for the new basis vector $v'_n$.

Recall from the comments before the proof that we do not actually multiply
matrices but only write a straight line program when we say ``construct''.
\item Consider transvections $t_i^c$ for $1 \le i \le n-1$.
\item Put together transvections $t_i$ for $n+1 \le i \le n'$.
\item Consider transvections $u_i^c$ for $1 \le i \le n-1$.
\item Put together new $n'$- and $(n'-1)$-cycles.
\end{enumerate}


\section{Conclusion}

Here we put everything together to prove our main Theorem~\ref{main}.

\begin{thebibliography}{999}

\bibitem{Asch}
M.~Aschbacher, \emph{On the maximal subgroups of the finite classical groups},
  Invent. Math. \textbf{76} (1984), 469--514.
  
\bibitem{Magma}
W.~Bosma and J.J. Cannon, \emph{Handbook of {{\sc Magma}} functions}, School of
  Mathematics and Statistics, University of Sydney, Sydney, 1995.

\bibitem{ATLAS}
J. Conway, R. Curtis, S. Norton, R. Parker, and R. Wilson, \emph{Atlas of
  {F}inite {G}roups}, Oxford University Press, 1985.
  
\bibitem{GAP4}
The {GAP} Group, \emph{{GAP} -- {G}roups, {A}lgorithms and {P}rogramming}, Version 4.4, 2004.

\bibitem{KL}
P.B. Kleidman and M.W. Liebeck, \emph{The {S}ubgroup {S}tructure of the
  {F}inite {C}lassical {G}roups}, London Math. Soc. Lecture Note Series, vol.
  129, Cambridge University Press, 1990.

\bibitem{LG99}
C.R.~Leedham-Green. \emph{The computational matrix group project.}
  Groups and computation, III (Columbus, OH, 1999), 229--247, 
  Ohio State Univ. Math. Res. Inst. Publ., 8, de Gruyter, Berlin, 2001.

\bibitem{NS06}
M.~Neunh{\"o}ffer and {\'A}kos Seress.
  \emph{A data structure for a uniform approach to computations with finite 
  groups.} ISSAC 2006, 254--261, ACM, New York, 2006. 

\bibitem{OB09}
E.A.~O'Brien. \emph{Algorithms for matrix groups.}
    Groups St Andrews 2009 in Bath, LMS Lecture Notes 388, 297--323, 2011.

\bibitem{Seress}
{\'A}. Seress, \emph{Permutation {G}roup {A}lgorithms}, Cambridge
  Tracts in Mathematics, vol. 152, Cambridge University Press, Cambridge, 2003.
  
\bibitem{WebAt}
R.A.~Wilson et~al., \emph{A {W}orld-{W}ide-{W}eb {A}tlas of finite group
  representations}, {\texttt{http://brauer.maths.qmul.ac.uk/Atlas/v3/}}.


\end{thebibliography}

\end{document}         
